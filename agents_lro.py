# -*- coding: utf-8 -*-
"""agents_LRO.ipynb
Automatically generated by Colab.
Original file is located at
    https://colab.research.google.com/drive/1voM2Fk5k7BVW0nBo2yW35Bi6quL_NWRW
"""


import os

from google.genai import types
from google.adk.agents import LlmAgent
from google.adk.runners import InMemoryRunner,Runner
from google.adk.sessions import InMemorySessionService
from google.adk.tools.mcp_tool.mcp_toolset import McpToolset
from google.adk.tools.mcp_tool.mcp_session_manager import StdioConnectionParams
from mcp import StdioServerParameters, Tool
from dotenv import load_dotenv
from google.adk.apps.app import App, ResumabilityConfig
from google.adk.tools.function_tool import FunctionTool
from google.adk.tools.tool_context import ToolContext
from google.genai.types import FunctionResponse


os.system('clear')

print("âœ… ADK components imported successfully.")

load_dotenv()

try:
    google_api_key = os.getenv("GOOGLE_API_KEY")
    openai_api_key = os.getenv("OPENAI_API_KEY")
    if not google_api_key or not openai_api_key:
        raise ValueError("GOOGLE_API_KEY and OPENAI_API_KEY must be set in the .env file.")
    os.environ["GOOGLE_API_KEY"] = google_api_key
    os.environ["OPENAI_API_KEY"] = openai_api_key
    print("âœ… Setup and authentication complete.")
except Exception as e:
    print(
        f"ðŸ”‘ Authentication Error: Please make sure you have added 'GOOGLE_API_KEY' and 'OPENAI_API_KEY' to your .env file. Details: {e}"
    )
    exit()

def display_image(file_path: str) -> str:
  """Displays an image from a file path if in a notebook; returns the path.

  Args:
    file_path: The local path to the image file.
  """
  try:
    from IPython.display import Image, display

    display(Image(filename=file_path))
    return f"Image displayed from {file_path}"
  except ImportError:
    return f"Image saved at {file_path}. Cannot display in this environment."
print("âœ… ADK components imported successfully.")

retry_config = types.HttpRetryOptions(
    attempts=5,  # Maximum retry attempts
    exp_base=7,  # Delay multiplier
    initial_delay=1,
    http_status_codes=[429, 500, 503, 504],  # Retry on these HTTP errors
)

import asyncio

async def main():
    """Runs the agent and prints the response."""
    image_tool = FunctionTool(
        func=display_image,
    )

    NUM_IMAGE_THRESHOLD=1

    def request_image_generation(num_image: int, tool_context: ToolContext):
        """
        Requests approval before generating multiple images.

        Acts as a gatekeeper for image generation. If the number of images
        exceeds NUM_IMAGE_THRESHOLD, requests user confirmation before proceeding.

        Args:
            num_image: Number of images to be generated.
            tool_context: ADK tool context for managing the confirmation flow.

        Returns:
            dict: Contains 'status' ('SUCCESS', 'PENDING', or 'REJECTED') and 'message'.
        """
        if(num_image<=NUM_IMAGE_THRESHOLD):
            return {
                "status": "SUCCESS",
                "message": "Image has been generated!"
            }
        if not tool_context.tool_confirmation:
            tool_context.request_confirmation(
                hint= "Need approval to generate multiple images. Please respond Y/n",
                payload={"num_image": num_image}
            )
            return {
                "status": "PENDING",
                "message": "Waiting for approval!"
            }
        else:
            if tool_context.tool_confirmation.confirmed:
                return {
                    "status": "SUCCESS",
                    "message": "Image has been generated!"
                
                }
            else:
                return {
                    "status":"REJECTED",
                    "message":"Unable to generate image"
                }

    # Define the MCP tool
    image_mcp_tool = McpToolset(
                connection_params=StdioConnectionParams(
                    timeout=120.0,  # 120 seconds for image generation
                    server_params=StdioServerParameters(
                        command='npx',
                        args=[
                            "-y",
                            "@singularity2045/image-generator-mcp-server",
                            "--",
                            f"--openai-api-key={os.getenv('OPENAI_API_KEY')}",
                            "--port=0",
                        ],
                    ),
                ),
            )

    # Define the Agent
    image_generator_agent = LlmAgent(
        model='gemini-2.5-flash-lite',
        name='image_generator_agent',
        instruction="""You are an expert at generating images.
When a user asks to generate an image, you must:
1. First call `request_image_generation` with the number of images requested. This handles approval for multiple images.
2. If approved (status is SUCCESS), call the `generate_image` MCP tool with a temporary file path (e.g., "/tmp/image.png").
3. After the image is generated, call `display_image` with the same file path to show the result.""",
        tools=[
            FunctionTool(func=request_image_generation),
            image_mcp_tool,
            image_tool,
        ],
    )

    # Wrap agent inside App
    image_generator_app = App(
        name="image_generator_app",
        root_agent=image_generator_agent,
        resumability_config=ResumabilityConfig(is_resumable=True),
    )

    # Define the Runner
    session_service = InMemorySessionService()

    runner = Runner(app=image_generator_app, session_service=session_service)

    def print_agent_response(events):
        """Prints text responses from agent events."""
        for event in events:
            if event.content and event.content.parts:
                for part in event.content.parts:
                    print(f"Agent response: {part}")
                
    def check_for_approval(events):
        """
        Checks events for an approval request from the agent.

        Args:
            events: List of agent events to scan.

        Returns:
            dict with 'approval_id', 'confirmed', and 'invocation_id' if found, else None.
        """
        for event in events:
            if event.content and event.content.parts:
                for part in event.content.parts:
                    if part.function_call and part.function_call.name == "adk_request_confirmation":
                        return {
                            "approval_id": part.function_call.id,
                            "invocation_id": event.invocation_id,
                        }
        return None

    def construct_adk_response(approval_id: str, confirmed: bool = True):
        """
        Constructs an ADK confirmation response to resume agent execution.

        Args:
            approval_id: The function call ID from the confirmation request.
            confirmed: Whether the user approved the action.

        Returns:
            types.Content with the FunctionResponse for resuming the agent.
        """
        adk_confirmation_response = FunctionResponse(
            id=approval_id,
            name="adk_request_confirmation",
            response={
                "confirmed": confirmed,
            }
        )

        return types.Content(
            role="user",
            parts=[types.Part(function_response=adk_confirmation_response)]
        )

    async def run_workflow(user_query: str,is_approved=True):
        """
        Runs the image generation workflow with approval handling.

        Creates a session, sends the user query to the agent, and handles
        any confirmation requests before resuming execution.

        Args:
            user_query: The user's image generation request.
        """
        import uuid
        session_id = str(uuid.uuid4())
        
        # Create a new session
        await session_service.create_session(app_name="image_generator_app", session_id=session_id,user_id="kaus123");
        
        events = []
        
        # Construct the query
        query = types.Content(parts=[types.Part(text=user_query)])
        
        # Call agent and add each event
        async for event in runner.run_async(user_id="kaus123",session_id=session_id,new_message=query):
            events.append(event)

        # Check for "adk_request_confirmation" event
        approval_info = check_for_approval(events)
        
        if approval_info:
            # Means agent is paused, need to resume agent execution with human input
            async for event in runner.run_async(user_id="kaus123",session_id=session_id,new_message=construct_adk_response(approval_info["approval_id"],is_approved),invocation_id=approval_info["invocation_id"]):
                if event.content and event.content.parts:
                    for part in event.content.parts:
                        print(f"Part: {part}")
        else:
            # No approval is needed, just print the agent response
            print_agent_response(events)
    
    
    await run_workflow('Generate 4 different images of a fish ',True) 
      
if __name__ == "__main__":
  asyncio.run(main())
